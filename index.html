<!DOCTYPE html>
<html>
  <head>
    <title>p5.js Collaborative Drawing</title>
    <meta charset="utf-8" />
    <style>
      body {
        margin: 0;
        padding: 0;
        overflow: hidden;
      }
      #info {
        position: absolute;
        top: 10px;
        left: 10px;
        background: rgba(255, 255, 255, 0.8);
        padding: 10px;
        border-radius: 5px;
        font-family: Arial, sans-serif;
        font-size: 14px;
        z-index: 1000;
      }
    </style>
  </head>
  <body>
    <div id="info">
      <strong>Controls:</strong><br />
      Left/Right Arrows: Move Player<br />
      Q/E: Rotate Paddle<br />
      Score points by hitting the goal with the ball!
    </div>

    <!-- Load p5.js from CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.min.js"></script>

    <!-- Load Socket.IO client from CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/2.0.3/socket.io.js"></script>
    <!-- Load Matter.js from CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.17.1/matter.min.js"></script>
    <!-- p5.js sketch -->
    <script>
      // Connect to the Socket.IO server (auto-connects to current origin)
      var socket = io();

      // Matter.js Setup
      const { Engine, World, Bodies, Body, Events, Constraint } = Matter;
      let engine, world;
      let ball, player, paddle, paddleConstraint, floor, roof, wall1, wall2, goal;
      //other vars/constants
      let score = 0;
      const CANVASX = 800;
      const CANVASY = 500;
      let BOUNCEFORCE = -10;
      let isHost = false;
      let players = {}; // Store other players
      let playerId = null;
      socket.on('connect', () => { playerId = socket.id; });
      let hostId = null;
      let hostAssigned = false;
      // Ball data from server (not a Matter.js body)
      let ballData = { x: 400, y: 250, vx: 5, vy: 2 };
      // Paddle rotation: track an explicit angle for predictable control
      let paddleAngle = 0;
      const ROTATION_SPEED = 0.05; // radians per 16.67ms frame (~per-frame at 60fps)
      const MIN_PADDLE_ANGLE = -1.2;
      const MAX_PADDLE_ANGLE = 1.2;

      // Host assignment logic might be redundant
      // let hostCheckInterval = setInterval(() => {
      //   if (!hostAssigned) {
      //     socket.emit('requestHost');
      //   }
      // }, 5000); // Check every 5 seconds

      // let hostTimeout = setTimeout(() => {
      //   if (!hostAssigned) {
      //     isHost = true;
      //     hostAssigned = true;
      //     socket.emit('assignHost');
      //     clearInterval(hostCheckInterval);
      //   }
      // }, 15000); // 15 seconds timeout

      function setup() {
        createCanvas(CANVASX, CANVASY);

        // Initialize Matter.js Engine and World
        engine = Engine.create();
        world = engine.world;
        //world.gravity.y = 10; // Set gravity

        // Create ball
        ball = Bodies.circle(10, 30, 15, {
          restitution: 0.8,
          frictionAir: 0.001,
        });
        World.add(world, ball);

        // Create player (circle for simplicity)
        player = Bodies.circle(random(100, CANVASX - 100), 465, 25, {
          isStatic: false,
          inertia: Infinity, // Prevent rotation from collisions
        });
        player.collisionFilter.group = -1; 
        World.add(world, player);

        // Create paddle as a dynamic body and attach it to the player with a constraint
        paddle = Bodies.rectangle(
          player.position.x,
          player.position.y - 32,
          100,
          15,
          { isStatic: false, frictionAir: 0.05 }
          
        );
        paddle.collisionFilter.group = -1; 
        World.add(world, paddle);

        // Create static walls

        floor = Bodies.rectangle(CANVASX / 2, CANVASY, CANVASX, 5, {
          isStatic: true,
        });
        roof = Bodies.rectangle(CANVASX / 2, 0, CANVASX, 5, { isStatic: true });
        wall1 = Bodies.rectangle(0, CANVASY / 2, 20, CANVASY, {
          isStatic: true,
        });
        wall2 = Bodies.rectangle(800, CANVASY, 50, CANVASY, {
          isStatic: true,
        });
        goal = Bodies.rectangle(785, 300, 30, 100, {
          isStatic: true,
          render: { fillStyle: "green" },
        });

        // Add static bodies to the world (rendering only)
        World.add(world, [floor, roof, wall1, wall2, goal]);
        // Server controls all physics - do NOT run Engine.run()   

} //end of setup

      // Helper: create a remote player's physics bodies (static so they don't interfere)
      function createRemotePlayer(id, data) {
        // avoid creating if it exists
        if (players[id]) return;
        const p = Bodies.circle(data.x || 100, data.y || 465, 25, { isStatic: true });
        const pad = Bodies.rectangle((data.x || 100), (data.y || 465) - 30, 90, 15, { isStatic: true });
        World.add(world, [p, pad]);
        players[id] = { body: p, paddle: pad };
      }

      function removeRemotePlayer(id) {
        const obj = players[id];
        if (!obj) return;
        World.remove(world, obj.body);
        World.remove(world, obj.paddle);
        delete players[id];
      }

      // handle initial state: create remote player bodies and sync our local player
      socket.on('initialState', (data) => {
        if (data.you) {
          playerId = data.you;
        }
        if (data.players) {
          Object.keys(data.players).forEach((id) => {
            const pd = data.players[id];
            if (id === playerId) {
              // sync our local player to server position
              Body.setPosition(player, { x: pd.x, y: pd.y });
            } else {
              createRemotePlayer(id, pd);
            }
          });
        }
      });

      // New player joined
      socket.on('newPlayer', (pd) => {
        if (pd && pd.id && pd.id !== playerId) {
          createRemotePlayer(pd.id, pd);
        }
      });

      // Player disconnected
      socket.on('playerDisconnected', (id) => {
        removeRemotePlayer(id);
      });

      function draw() {
        background(100);

        // Handle player movement (left/right) and paddle rotation (Q/E)
        let moveDir = 0;
        if (keyIsDown(LEFT_ARROW)) {
          moveDir = -1;
        } else if (keyIsDown(RIGHT_ARROW)) {
          moveDir = 1;
        }
        
        // Update player position locally for immediate feedback
        if (moveDir !== 0) {
          const newX = player.position.x + moveDir * 3;
          // Clamp to canvas bounds
          Body.setPosition(player, { 
            x: constrain(newX, 30, CANVASX - 30), 
            y: player.position.y 
          });
        }

        // Physics-based paddle rotation using angular velocity with a constraint to follow the player
        const dt = typeof deltaTime !== 'undefined' ? deltaTime : 16.6667;
        const frameScale = dt / 16.6667;
        const ANG_VEL = 0.15; // tweak for responsiveness
        if (keyIsDown(81)) { // Q
          Body.setAngularVelocity(paddle, -ANG_VEL * frameScale);
        } else if (keyIsDown(69)) { // E
          Body.setAngularVelocity(paddle, ANG_VEL * frameScale);
        } else {
          // gentle damping when no input
          Body.setAngularVelocity(paddle, paddle.angularVelocity * 0.9);
        }

        // Clamp angle limits to avoid flipping too far
        if (paddle.angle < MIN_PADDLE_ANGLE) {
          Body.setAngle(paddle, MIN_PADDLE_ANGLE);
          Body.setAngularVelocity(paddle, 0);
        } else if (paddle.angle > MAX_PADDLE_ANGLE) {
          Body.setAngle(paddle, MAX_PADDLE_ANGLE);
          Body.setAngularVelocity(paddle, 0);
        }
        
        // Lock linear velocities to zero, keep angular velocity for rotation
        Body.setVelocity(paddle, { x: 0, y: 0 });
        Body.setVelocity(player, { x: 0, y: 0 });
        // Update paddle position but preserve its angle
        const paddleAngle = paddle.angle;
        Body.setPosition(paddle, { x: player.position.x, y: player.position.y - 30 });
        Body.setAngle(paddle, paddleAngle);

        // Display game entities
        fill(255);
        // Draw the ball
        ellipse(ballData.x, ballData.y, 30); // Draw the main circle

        // Draw a small line on the edge of the circle to show rotation
        let radius = 15; // Half the diameter of the ball
        let indicatorLength = 10;
        // Draw indicator based on velocity direction
        let angle = Math.atan2(ballData.vy, ballData.vx);
        let endX = ballData.x + (radius + indicatorLength / 2) * cos(angle);
        let endY = ballData.y + (radius + indicatorLength / 2) * sin(angle);

        // Draw the indicator line
        stroke(255, 0, 0); // Red color for visibility
        strokeWeight(3);
        line(ballData.x, ballData.y, endX, endY);
        noStroke(); // Reset stroke for other elements

        // Draw local player as a circle
        fill(255);
        ellipse(player.position.x, player.position.y, 50, 50); // Draw player
        // Draw paddle with rotation applied
        push();
        translate(paddle.position.x, paddle.position.y);
        rotate(paddle.angle);
        fill(255);
        rect(-45, -8, 90, 16); // Centered rectangle, height 16
        pop();

        // Draw remote players and their paddles
        fill(200); // Darker fill for remote players
        Object.keys(players).forEach((id) => {
          const p = players[id];
          if (p && p.body && p.paddle) {
            // Draw remote player body as a circle
            ellipse(p.body.position.x, p.body.position.y, 50, 50);
            // Draw remote player paddle with rotation
            push();
            translate(p.paddle.position.x, p.paddle.position.y);
            rotate(p.paddle.angle);
            rect(-45, -8, 90, 16); // Centered rectangle, height 16
            pop();
          }
        });
        fill(255); // Reset fill for other elements

        // Server handles all collisions and scoring

        // Score
        text("Score: " + score, 10, 30);
      } //end of draw

      // Physics and collision detection handled entirely by server
      // Client-side bodies are for rendering only

      // Send player position and paddle rotation
      setInterval(() => {
        let playerData = {
          id: playerId,
          x: player.position.x,
          y: player.position.y,
          paddleRotation: paddle.angle,
        };
        socket.emit("playerUpdate", playerData);
      }, 50);

      // Receive updates from other players
      socket.on("playerUpdate", (data) => {
        if (data.id !== playerId) {
          // Update other players' positions and paddles
          let other = players[data.id];
          if (other) {
            Body.setPosition(other.body, { x: data.x, y: data.y });
            // Sync paddle position to stay above the remote player
            Body.setPosition(other.paddle, { x: data.x, y: data.y - 30 });
            Body.setAngle(other.paddle, data.paddleRotation);
          } else {
            // If we don't have a body yet, create one
            createRemotePlayer(data.id, data);
            if (players[data.id]) {
              Body.setPosition(players[data.id].body, { x: data.x, y: data.y });
              Body.setPosition(players[data.id].paddle, { x: data.x, y: data.y - 30 });
              Body.setAngle(players[data.id].paddle, data.paddleRotation);
            }
          }
        }
      });

      // Server controls ball physics - all clients receive ballUpdate
      socket.on("ballUpdate", (data) => {
        ballData.x = data.x;
        ballData.y = data.y;
        ballData.vx = data.vx;
        ballData.vy = data.vy;
      });

      // Receive score updates from server
      socket.on("scoresUpdate", (scoresData) => {
        // Update local score if it exists for this player
        if (scoresData[playerId] !== undefined) {
          score = scoresData[playerId];
        }
      });

      // Resize canvas when window is resized
      function windowResized() {
        resizeCanvas(windowWidth, windowHeight);
      }
    </script>
  </body>
</html>
