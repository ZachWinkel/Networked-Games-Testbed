<!DOCTYPE html>
<html>
  <head>
    <title>p5.js Collaborative Drawing</title>
    <meta charset="utf-8" />
    <style>
      body {
        margin: 0;
        padding: 0;
        overflow: hidden;
        display: flex;
        justify-content: center;
        align-items: center;
        min-height: 100vh;
        background-color: #222;
      }
      #canvas-container {
        position: relative;
      }
      #p5-container {
        display: inline-block;
      }
      #info {
        position: absolute;
        top: 10px;
        left: 10px;
        background: rgba(255, 255, 255, 0.8);
        padding: 10px;
        border-radius: 5px;
        font-family: Arial, sans-serif;
        font-size: 14px;
        z-index: 1000;
      }
    </style>
  </head>
  <body>
    <div id="canvas-container">
      <div id="p5-container"></div>
      <div id="info">
        <strong>Controls:</strong><br />
        Left/Right Arrows: Move Player<br />
        Q/E: Rotate Paddle<br />
        Score points by hitting the goal with the ball!
      </div>
    </div>

    <!-- Load p5.js from CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.min.js"></script>

    <!-- Load p5.sound library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/addons/p5.sound.min.js"></script>

    <!-- Load Socket.IO client from CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/2.0.3/socket.io.js"></script>
    <!-- Load Matter.js from CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.17.1/matter.min.js"></script>
    <!-- p5.js sketch -->
    <script>
      // Connect to the Socket.IO server (auto-connects to current origin)
      var socket = io();

      // Matter.js Setup
      const { Engine, World, Bodies, Body, Events, Constraint } = Matter;
      let engine, world;
      let ball, player, paddle, paddleConstraint, floor, roof, wall1, wall2, goal;
      let goalSound; // Sound for goal scoring
      //other vars/constants
      let score = 0;
      const CANVASX = 800;
      const CANVASY = 500;
      let goalY = 250; // Track goal Y position
      let players = {}; // Store other players
      let playerId = null;
      socket.on('connect', () => { 
        playerId = socket.id;
        // Generate random colors for the local player after connection
        playerColors[playerId] = {
          bodyColor: color(random(50, 200), random(50, 200), random(50, 200)),
          paddleColor: color(random(50, 200), random(50, 200), random(50, 200))
        };
      });
      let playerColors = {}; // Map player ID to {bodyColor, paddleColor}

      // Ball data from server (not a Matter.js body)
      let ballData = { x: 400, y: 250, vx: 5, vy: 2 };
      // Paddle rotation: track an explicit angle for predictable control
      let paddleAngle = 0;
      const ROTATION_SPEED = 0.05; // radians per 16.67ms frame (~per-frame at 60fps)
      const MIN_PADDLE_ANGLE = -1.2;
      const MAX_PADDLE_ANGLE = 1.2;

      function preload() {
        // Try to load goal sound, but don't break if it fails
        goalSound = null; // Initialize as null
        try {
          goalSound = createAudio('Sounds/video-game-bonus-323603.mp3');
        } catch (e) {
          console.log('Sound loading failed - game will continue without sound');
        }
      }

      function setup() {
        const container = document.getElementById('p5-container');
        const canvas = createCanvas(CANVASX, CANVASY);
        canvas.parent('p5-container');

        // Initialize Matter.js Engine and World
        engine = Engine.create();
        world = engine.world;
        //world.gravity.y = 10; // Set gravity

        // Create ball
        ball = Bodies.circle(10, 30, 15, {
          restitution: 0.8,
          frictionAir: 0.001,
        });
        World.add(world, ball);

        // Create player (circle for simplicity)
        player = Bodies.circle(random(100, CANVASX - 100), 465, 25, {
          isStatic: false,
          inertia: Infinity, // Prevent rotation from collisions
        });
        // Set collision filter: category 1, collide only with floor (category 64)
        player.collisionFilter.category = 1;
        player.collisionFilter.mask = 64;
        World.add(world, player);

        // Create paddle as a dynamic body and attach it to the player with a constraint
        paddle = Bodies.rectangle(
          player.position.x,
          player.position.y - 32,
          100,
          15,
          { isStatic: false, frictionAir: 0.05 }
          
        );
        // Set collision filter: category 2, collide only with floor (category 64)
        paddle.collisionFilter.category = 2;
        paddle.collisionFilter.mask = 64; 
        World.add(world, paddle);

        // Create static walls

        floor = Bodies.rectangle(CANVASX / 2, CANVASY, CANVASX, 5, {
          isStatic: true,
        });
        // Set collision filter for floor: category 64, collides with players (1, 2) and ball
        floor.collisionFilter.category = 64;
        floor.collisionFilter.mask = 1 | 2 | 4; // collide with player, paddle, and remote players
        roof = Bodies.rectangle(CANVASX / 2, 0, CANVASX, 5, { isStatic: true });
        wall1 = Bodies.rectangle(0, CANVASY / 2, 20, CANVASY, {
          isStatic: true,
        });
        wall2 = Bodies.rectangle(800, CANVASY, 50, CANVASY, {
          isStatic: true,
        });
        goal = Bodies.rectangle(785, 300, 30, 100, {
          isStatic: true,
          render: { fillStyle: "green" },
        });
  
        // Add static bodies to the world (rendering only)
        World.add(world, [floor, roof, wall1, wall2, goal]);
        // Server controls all physics - do NOT run Engine.run()   

} //end of setup

      // Helper: create a remote player's physics bodies (static so they don't interfere)
      function createRemotePlayer(id, data) {
        // avoid creating if it exists
        if (players[id]) return;
        const p = Bodies.circle(data.x || 100, data.y || 465, 25, { isStatic: true });
        const pad = Bodies.rectangle((data.x || 100), (data.y || 465) - 30, 90, 15, { isStatic: true });
        // Set collision filters to not collide with anything except floor
        p.collisionFilter.category = 4;
        p.collisionFilter.mask = 64;
        pad.collisionFilter.category = 8;
        pad.collisionFilter.mask = 64;
        World.add(world, [p, pad]);
        // Generate random colors for this remote player
        playerColors[id] = {
          bodyColor: color(random(50, 200), random(50, 200), random(50, 200)),
          paddleColor: color(random(50, 200), random(50, 200), random(50, 200))
        };
        players[id] = { body: p, paddle: pad };
      }

      function removeRemotePlayer(id) {
        const obj = players[id];
        if (!obj) return;
        World.remove(world, obj.body);
        World.remove(world, obj.paddle);
        delete players[id];
      }

      // handle initial state: create remote player bodies and sync our local player
      socket.on('initialState', (data) => {
        if (data.you) {
          playerId = data.you;
        }
        if (data.goalY !== undefined) {
          goalY = data.goalY;
        }
        if (data.players && player) {
          Object.keys(data.players).forEach((id) => {
            const pd = data.players[id];
            if (id === playerId && player && player.position) {
              // sync our local player to server position
              Body.setPosition(player, { x: pd.x, y: pd.y });
            } else if (id !== playerId) {
              createRemotePlayer(id, pd);
            }
          });
        }
      });

      // New player joined
      socket.on('newPlayer', (pd) => {
        if (pd && pd.id && pd.id !== playerId) {
          createRemotePlayer(pd.id, pd);
        }
      });

      // Player disconnected
      socket.on('playerDisconnected', (id) => {
        removeRemotePlayer(id);
      });

      function draw() {
        background(50);
        
        // Update Matter.js bodies (required for angular velocity to work)
        Engine.update(engine, 1000 / 60);

        // Draw floor
        fill(100);
        rect(0, CANVASY - 10, CANVASX, 10);
        
        // Draw left wall
        fill(100);
        rect(0, 0, 10, CANVASY);
        
        // Draw right wall
        fill(100);
        rect(CANVASX - 10, 0, 10, CANVASY);
        
        // Draw top wall
        fill(100);
        rect(0, 0, CANVASX, 10);
        
        // Draw goal zone (right side) - dynamically positioned
        fill(50, 200, 50, 100);
        rect(750, goalY - 50, 50, 100);

        // Handle player movement (left/right) and paddle rotation (Q/E)
        let moveDir = 0;
        if (keyIsDown(LEFT_ARROW)) {
          moveDir = -1;
        } else if (keyIsDown(RIGHT_ARROW)) {
          moveDir = 1;
        }
        
        // Update player position locally for immediate feedback
        if (moveDir !== 0) {
          const newX = player.position.x + moveDir * 3;
          // Clamp to canvas bounds
          Body.setPosition(player, { 
            x: constrain(newX, 30, CANVASX - 30), 
            y: player.position.y 
          });
        }

        // Manual paddle angle control (deterministic and responsive)
        const dt = typeof deltaTime !== 'undefined' ? deltaTime : 16.6667;
        const frameScale = dt / 16.6667;
        const ROT_SPEED = 0.06; // radians per frame at 60fps
        // initialize paddleAngle if missing
        if (typeof paddleAngle === 'undefined') {
          paddleAngle = paddle.angle || 0;
        }
        if (keyIsDown(81)) { // Q
          paddleAngle -= ROT_SPEED * frameScale;
        } else if (keyIsDown(69)) { // E
          paddleAngle += ROT_SPEED * frameScale;
        }
        // Clamp angle limits to avoid flipping too far
        paddleAngle = Math.max(MIN_PADDLE_ANGLE, Math.min(MAX_PADDLE_ANGLE, paddleAngle));

        // Apply angle and keep paddle positioned above player
        Body.setAngle(paddle, paddleAngle);
        Body.setVelocity(paddle, { x: 0, y: 0 });
        Body.setVelocity(player, { x: 0, y: 0 });
        Body.setPosition(paddle, { x: player.position.x, y: player.position.y - 30 });

        // Display game entities
        fill(255);
        // Draw the ball
        ellipse(ballData.x, ballData.y, 30); // Draw the main circle

        // Draw a small line on the edge of the circle to show rotation
        let radius = 15; // Half the diameter of the ball
        let indicatorLength = 10;
        // Draw indicator based on velocity direction
        let angle = Math.atan2(ballData.vy, ballData.vx);
        let endX = ballData.x + (radius + indicatorLength / 2) * cos(angle);
        let endY = ballData.y + (radius + indicatorLength / 2) * sin(angle);

        // Draw the indicator line
        stroke(255, 0, 0); // Red color for visibility
        strokeWeight(3);
        line(ballData.x, ballData.y, endX, endY);
        noStroke(); // Reset stroke for other elements

        // Draw local player as a circle
        if (playerColors[playerId]) {
          fill(playerColors[playerId].bodyColor);
        }
        ellipse(player.position.x, player.position.y, 50, 50); // Draw player
        // Draw paddle with rotation applied
        push();
        translate(paddle.position.x, paddle.position.y);
        rotate(paddle.angle);
        if (playerColors[playerId]) {
          fill(playerColors[playerId].paddleColor);
        }
        rect(-45, -8, 90, 16); // Centered rectangle, height 16
        pop();

        // Draw remote players and their paddles
        Object.keys(players).forEach((id) => {
          const p = players[id];
          if (p && p.body && p.paddle) {
            // Draw remote player body as a circle
            if (playerColors[id]) {
              fill(playerColors[id].bodyColor);
            }
            ellipse(p.body.position.x, p.body.position.y, 50, 50);
            // Draw remote player paddle with rotation
            push();
            translate(p.paddle.position.x, p.paddle.position.y);
            rotate(p.paddle.angle);
            if (playerColors[id]) {
              fill(playerColors[id].paddleColor);
            }
            rect(-45, -8, 90, 16); // Centered rectangle, height 16
            pop();
          }
        });
        fill(255); // Reset fill for other elements

        // Server handles all collisions and scoring

        // Score
        text("Score: " + score, 10, 30);
      } //end of draw

      // Physics and collision detection handled entirely by server
      // Client-side bodies are for rendering only

      // Send player position and paddle rotation
      setInterval(() => {
        if (player && player.position && paddle && paddle.angle !== undefined) {
          let playerData = {
            id: playerId,
            x: player.position.x,
            y: player.position.y,
            paddleRotation: paddle.angle,
          };
          socket.emit("playerUpdate", playerData);
        }
      }, 50);

      // Receive updates from other players
      socket.on("playerUpdate", (data) => {
        if (data.id !== playerId) {
          // Update other players' positions and paddles
          let other = players[data.id];
          if (other && other.body && other.paddle) {
            Body.setPosition(other.body, { x: data.x, y: data.y });
            // Sync paddle position to stay above the remote player
            Body.setPosition(other.paddle, { x: data.x, y: data.y - 30 });
            Body.setAngle(other.paddle, data.paddleRotation);
          } else {
            // If we don't have a body yet, create one
            createRemotePlayer(data.id, data);
            if (players[data.id] && players[data.id].body && players[data.id].paddle) {
              Body.setPosition(players[data.id].body, { x: data.x, y: data.y });
              Body.setPosition(players[data.id].paddle, { x: data.x, y: data.y - 30 });
              Body.setAngle(players[data.id].paddle, data.paddleRotation);
            }
          }
        }
      });

      // Server controls ball physics - all clients receive ballUpdate
      socket.on("ballUpdate", (data) => {
        ballData.x = data.x;
        ballData.y = data.y;
        ballData.vx = data.vx;
        ballData.vy = data.vy;
      });

      // Listen for goal position updates from server
      socket.on("goalYUpdate", (newGoalY) => {
        goalY = newGoalY;
      });

      // Receive score updates from server
      socket.on("scoresUpdate", (scoresData) => {
        // Update local score if it exists for this player
        if (scoresData[playerId] !== undefined) {
          score = scoresData[playerId];
          // Try to play goal sound (gracefully fail if not available)
          if (goalSound) {
            try {
              goalSound.play();
            } catch (e) {
              // Sound failed, but game continues
            }
          }
        }
      });

      // Resize canvas when window is resized
      function windowResized() {
        resizeCanvas(windowWidth, windowHeight);
      }
    </script>
  </body>
</html>
