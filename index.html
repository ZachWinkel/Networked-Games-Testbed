<!DOCTYPE html>
<html>
  <head>
    <title>p5.js Collaborative Drawing</title>
    <meta charset="utf-8" />
    <style>
      body {
        margin: 0;
        padding: 0;
        overflow: hidden;
      }
      #info {
        position: absolute;
        top: 10px;
        left: 10px;
        background: rgba(255, 255, 255, 0.8);
        padding: 10px;
        border-radius: 5px;
        font-family: Arial, sans-serif;
        font-size: 14px;
        z-index: 1000;
      }
    </style>
  </head>
  <body>
    <div id="info">
      Draw with your mouse! Other users appear in red.<br />
      Open in multiple tabs to test multiplayer.
    </div>

    <!-- Load p5.js from CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.min.js"></script>

    <!-- Load Socket.IO client from CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/2.0.3/socket.io.js"></script>

    <!-- p5.js sketch -->
    <script>
     // Connect to the Socket.IO server (auto-connects to current origin)
    var socket = io();
 // Matter.js Setup
const { Engine, World, Bodies, Body, Events } = Matter;
let engine, world;
let ball, player, paddle, floor, roof, wall1, wall2, goal;
//other vars/constants
let score = 0;
const CANVASX = 800;
const CANVASY = 500;
const BALLSPAWNX = 10;
const BALLSPAWNY = 100;

   
 

function setup() {
  createCanvas(CANVASX, CANVASY);

  // Initialize Matter.js Engine and World
  engine = Engine.create();
  world = engine.world;
  world.gravity.y = 10; // Set gravity

  // Create ball
  ball = Bodies.circle(10, 30, 15, { restitution: 0.8, frictionAir: 0.01 });
  World.add(world, ball);

  // Create player (rectangle for simplicity)
  player = Bodies.rectangle(random(100, CANVASX - 100), 465, 50, 50, { isStatic: false });
  World.add(world, player);

  // Create paddle
  paddle = Bodies.rectangle(player.position.x, player.position.y - 30, 90, 15, { isStatic: true });
  World.add(world, paddle);

  // Create static walls
  floor = Bodies.rectangle(CANVASX / 2, CANVASY, CANVASX, 5, { isStatic: true });
  roof = Bodies.rectangle(CANVASX / 2, 0, CANVASX, 5, { isStatic: true });
  wall1 = Bodies.rectangle(CANVASX, CANVASY / 2, 5, CANVASY, { isStatic: true });
  wall2 = Bodies.rectangle(0, CANVASX / 2, 5, CANVASY, { isStatic: true });
  goal = Bodies.rectangle(785, 300, 30, 100, { isStatic: true, render: { fillStyle: 'green' } });

  // Add static bodies to the world
  World.add(world, [floor, roof, wall1, wall2, goal]);

  // Matter.js engine run
  Engine.run(engine);
} //end of setup








function draw() {
  background(100);

  // Handle player movement (left/right) and paddle rotation (Q/E)
  if (keyIsDown(LEFT_ARROW)) {
    Body.applyForce(player, player.position, { x: -0.05, y: 0 });
  } else if (keyIsDown(RIGHT_ARROW)) {
    Body.applyForce(player, player.position, { x: 0.05, y: 0 });
  }

  if (keyIsDown(81)) {  // Q key
    Body.rotate(paddle, -0.05); // Rotate paddle counter-clockwise
  } else if (keyIsDown(69)) {  // E key
    Body.rotate(paddle, 0.05);  // Rotate paddle clockwise
  }

  // Sync player position with paddle
  Body.setPosition(paddle, { x: player.position.x, y: player.position.y - 30 });

  // Display game entities
  fill(255);
  ellipse(ball.position.x, ball.position.y, 30);
  rect(player.position.x - 25, player.position.y - 25, 50, 50); // Draw player
  rect(paddle.position.x - 45, paddle.position.y - 7, 90, 15); // Draw paddle

  // Check for ball collisions with the goal
  if (Matter.SAT.collides(ball, goal).collided) {
    score += 1;
    resetBall();
  }

  // Ball collision with floor or walls
  if (ball.position.y > CANVASY) {
    resetBall();
  }

  // Score
  text("Score: " + score, 10, 30);
}//end of draw

function resetBall() {
  // Reset ball to the spawn position
  Body.setPosition(ball, { x: BALLSPAWNX, y: BALLSPAWNY });
  Body.setVelocity(ball, { x: 3, y: 0 });
}

function checkBallCollisions() {
  // Collision with paddle
  if (Matter.SAT.collides(ball, paddle).collided) {
    Body.setVelocity(ball, { x: ball.velocity.x, y: BOUNCEFORCE });
  }

  // Collision with walls or floor
  if (ball.position.y > CANVASY) {
    resetBall();
  }
}

// Send player position and paddle rotation
setInterval(() => {
  let playerData = {
    id: player.id,
    x: player.position.x,
    y: player.position.y,
    paddleRotation: paddle.angle
  };
  socket.emit('playerUpdate', playerData);
}, 50);

// Receive updates from other players
socket.on('playerUpdate', (data) => {
  if (data.id !== player.id) {
    // Update other players' positions and paddles
    let otherPlayer = players[data.id];
    if (otherPlayer) {
      Body.setPosition(otherPlayer, { x: data.x, y: data.y });
      Body.setAngle(paddle, data.paddleRotation);
    }
  }
});


if (isHost) {
  socket.emit('updateBall', { x: ball.position.x, y: ball.position.y, velocity: ball.velocity, velX: ball.velocity.x,
        velY: ball.velocity.y });
}

// Client receiving ball position updates
socket.on('updateBall', (data) => {
  if (!isHost) {
    let errorX = data.x - ball.position.x;
    let errorY = data.y - ball.position.y;
    Body.setPosition(ball, { x: ball.position.x + errorX * 0.3, y: ball.position.y + errorY * 0.3 });
    Body.setVelocity(ball, data.velocity);
  }
});



      // Resize canvas when window is resized
      function windowResized() {
        resizeCanvas(windowWidth, windowHeight);
      }








    </script>
  </body>
</html>
